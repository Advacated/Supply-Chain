import numpy as np
import pandas as pd
from pathlib import Path


def generate_supply_chain_dataset(
    num_products: int = 500,
    num_locations: int = 50,
    num_weeks: int = 120,
    output_path: str = "supply_chain_dataset_3M.csv",
    random_seed: int = 42,
) -> None:
    """
    Generate a synthetic supply chain dataset with multi-million rows.

    Total rows = num_products * num_locations * num_weeks

    Columns:
      - week_id
      - date (week label, e.g. 2024-W01)
      - product_id
      - location_id
      - seasonality_index
      - promotion_flag
      - holiday_flag
      - markdown_factor
      - true_demand
      - forecast_v1
      - forecast_v2
      - lead_time_weeks
      - holding_cost_per_unit
      - stockout_cost_per_unit
      - expedite_cost_per_unit
    """

    rng = np.random.default_rng(random_seed)

    products = [f"P{str(i+1).zfill(4)}" for i in range(num_products)]
    locations = [f"L{str(i+1).zfill(3)}" for i in range(num_locations)]
    weeks = np.arange(1, num_weeks + 1)

    output_path = Path(output_path)

    columns = [
        "week_id",
        "date",
        "product_id",
        "location_id",
        "seasonality_index",
        "promotion_flag",
        "holiday_flag",
        "markdown_factor",
        "true_demand",
        "forecast_v1",
        "forecast_v2",
        "lead_time_weeks",
        "holding_cost_per_unit",
        "stockout_cost_per_unit",
        "expedite_cost_per_unit",
    ]

    # Write header once
    with output_path.open("w", newline="") as f:
        f.write(",".join(columns) + "\n")

    def seasonality(weeks_arr, amp, phase):
        """
        Simple sinusoidal seasonality: amplitude amp, phase shift phase.
        52-week cycle.
        """
        return 1 + amp * np.sin(2 * np.pi * (weeks_arr + phase) / 52.0)

    total_rows = len(products) * len(locations) * len(weeks)
    print(f"Generating dataset with ~{total_rows:,} rows...")
    print(f"Output: {output_path.resolve()}")

    # Main generation loop â€“ chunked by product & location
    for p_idx, p in enumerate(products, start=1):
        # Product-level parameters
        base_demand = rng.integers(20, 200)
        vol_coeff = rng.uniform(0.2, 0.5)  # relative volatility
        amp = rng.uniform(0.1, 0.3)        # seasonality amplitude
        phase = rng.integers(0, 52)        # seasonality phase

        season_vals = seasonality(weeks, amp, phase)
        # Mark some holiday weeks (can adjust to your liking)
        holiday_flags = np.isin(weeks, [50, 51, 52]).astype(int)

        for l_idx, l in enumerate(locations, start=1):
            # Location-level parameters
            loc_mult = rng.choice(np.array([1.2, 1.0, 0.8]))

            holding_cost = rng.uniform(0.05, 0.50)
            stockout_cost = rng.uniform(5.0, 20.0)
            expedite_cost = rng.uniform(2.0, 8.0)
            lead_time = int(rng.integers(1, 4))

            # Week-level stochastic features
            promo_flags = (rng.random(num_weeks) < 0.12).astype(int)  # ~12% promo weeks
            markdown_factors = rng.choice(
                np.array([1.0, 0.9, 1.1]), size=num_weeks
            )

            promo_lifts = 1 + promo_flags * rng.uniform(0.2, 0.8, size=num_weeks)
            holiday_lifts = 1 + holiday_flags * rng.uniform(0.1, 0.5, size=num_weeks)

            # Mean demand per week
            mu = (
                base_demand
                * loc_mult
                * season_vals
                * promo_lifts
                * holiday_lifts
                * markdown_factors
            )

            sigma = vol_coeff * mu  # std dev scales with demand level

            # True demand (non-negative integers)
            true_demand = np.maximum(0, rng.normal(mu, sigma).astype(int))

            # Forecasts (v1 noisier than v2)
            forecast_v1 = np.maximum(
                0, (mu * rng.normal(1.0, 0.20, size=num_weeks)).astype(int)
            )
            forecast_v2 = np.maximum(
                0, (mu * rng.normal(1.0, 0.10, size=num_weeks)).astype(int)
            )

            # Build DataFrame for this (product, location)
            df = pd.DataFrame(
                {
                    "week_id": weeks,
                    "date": [f"2024-W{str(w).zfill(2)}" for w in weeks],
                    "product_id": p,
                    "location_id": l,
                    "seasonality_index": season_vals,
                    "promotion_flag": promo_flags,
                    "holiday_flag": holiday_flags,
                    "markdown_factor": markdown_factors,
                    "true_demand": true_demand,
                    "forecast_v1": forecast_v1,
                    "forecast_v2": forecast_v2,
                    "lead_time_weeks": lead_time,
                    "holding_cost_per_unit": holding_cost,
                    "stockout_cost_per_unit": stockout_cost,
                    "expedite_cost_per_unit": expedite_cost,
                }
            )

            # Append without header
            df.to_csv(output_path, mode="a", header=False, index=False)

        # Optional: progress log
        if p_idx % 25 == 0:
            print(f"  Finished products: {p_idx}/{num_products}")

    print("Done!")


if __name__ == "__main__":
    # ðŸ‘‰ TUNE THESE TO CONTROL SIZE
    NUM_PRODUCTS = 500
    NUM_LOCATIONS = 50
    NUM_WEEKS = 120  # 500 * 50 * 120 = 3,000,000 rows

    generate_supply_chain_dataset(
        num_products=NUM_PRODUCTS,
        num_locations=NUM_LOCATIONS,
        num_weeks=NUM_WEEKS,
        output_path="supply_chain_dataset_3M.csv",
        random_seed=42,
    )
